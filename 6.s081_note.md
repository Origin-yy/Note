## 第一节

1. 操作系统一般需要做到：
   + 抽象硬件，实现了高层级的接口和抽象，例如进程，文件系统。
   + 在多个应用程序之间共用硬件资源，多个程序能够互不干扰地运行，multiplex（多路复用）。
   + 多个程序之间互不干扰。隔离性（Isolation），不同的活动之间不能相互干扰。
   + 能在需要的时候实现共享（Sharing）。
   + Security或者Permission System或者是Access Control System（权限系统或者门禁系统）。
   + 不阻止应用程序获得高性能，甚至需要帮助应用程序获得高性能（Performance）。
   + 同一个操作系统需要能够支持大量不同的用户场景。
2. Kernel中的服务：文件系统，进程管理系统。
3. 系统调用与程序中的函数调用的区别是系统调用会实际运行到系统内核中，并执行内核中对于系统调用的实现。Kernel会有特殊的权限能直接访问各种各样的硬件，例如磁盘。而普通的用户程序是没有办法直接访问这些硬件的。
4. 构建操作系统时，在操作系统下面就是硬件，编程环境比较恶劣。1.高效易用—接近硬件底层，为应用程序提供抽象的高层的可移植接口。2.要提供一个简单的接口，同时又包含了强大的功能。3.需要内核具备灵活的接口，又需要在某种程度上限制应用程序，因为你会想要安全性。我们希望给程序员完全的自由，但是实际上又不能是真正的完全自由。
5. fork还会拷贝文件描述符表单。两个进程的指令是一样的，数据是一样的，栈是一样的，同时，两个进程又有各自独立的地址空间，它们都认为自己的内存从0开始增长，但这里是不同的内存。有一些细节偶尔会导致父子进程不一致。子进程fork()返回0,父进程返回子进程进程号。子进程不会从main()函数开始执行，而是直接从fork()系统调用返回，就好像是他自己调用了fork。
6. `exec("filename"，argv)`从指定的文件中读取并加载指令，并替代当前调用进程的指令。会保留当前的文件描述符表单，通常来说exec系统调用不会返回，除非调用出错返回-1。
7. Shell会执行fork，之后fork出的子进程再调用exec5系统调用。
8. `fork()`的子进程用`exit(num)`退出后，在父进程中可以用`wait(&status)`来获取子进程的退出状态。wait()的返回值是子进程号，`status`的值即是子进程`exit()`的参数的值。
9. 如果没有子进程的进程调用了wait，wait会立即返回-1，表明出现错误了。没有直接的方法让子进程等待父进程退出。
10. 如果一个进程调用fork两次，如果它想要等两个子进程都退出，它需要调用wait两次。每个wait会在一个子进程退出时立即返回。当wait返回时，你实际上没有必要知道哪个子进程退出了，但是wait返回了子进程的进程号，所以在wait返回之后，你就可以知道是哪个子进程退出了。
11. `int fd[2]; pipe(fd)`创建管道，`fd[0]`用来从管道读数据，`fd[1]`用来向管道写数据。返回0代表成功，返回-1失败。管道是不是文件取决于操作系统创建管道的方式，一般来说用pipe()创建的管道都不是文件。而创建基于文件的管道，通常叫做有名管道或FIFO文件（先进先出文件）。两个进程只要知道管道的名字也能用它来通信，即使它们是非父子进程关系。如果试图读取一个空的管道，也不会发生错误，因为程序会等待管道中出现东西。当子进程结束时，管道会关闭。f`gets()`将会收到`EOF`(End Of File,文件结束符） ，于是`fgets()`函数返回0，循环就结束了。管道只能单向通信。但是可以通过创建两个管道，一个从父进程连接到子进程，另一个从子进程连接到父进程来实现双向通信 。

## 第三节

1. 需要操作系统的隔离性，保证应用程序间不会相互影响。需要操作系统抽象硬件资源，不让应用程序看到硬件资源。一个应用程序不能长时间占用CPU,需要协同调度，如果没有操作系统，这很难。从内存的角度来说，如果应用程序直接运行在硬件资源之上，那么每个应用程序的文本，代码和数据都直接保存在物理内存中。这可能会导致一个程序越界操作另一个程序的内存。

2. fork创建了进程。进程本身不是CPU，但是它们对应了CPU，它们使得你可以在CPU上运行计算任务。应用程序不能直接与CPU交互，只能与进程交互。操作系统内核会完成不同进程在CPU上的切换。所以，**操作系统不是直接将CPU提供给应用程序，而是向应用程序提供“进程”，进程抽象了CPU，这样操作系统才能在多个应用程序之间复用一个或者多个CPU。**
3. 处理器有几个核，就可以同时运行几个进程，但可以分时复用CPU，比如一个进程用100ms , 之后，另一个进程用100ms。

4. 我们可以认为exec抽象了内存。当我们在执行exec系统调用的时候，我们会传入一个文件名，而这个文件名对应了一个应用程序的内存镜像。内存镜像里面包括了程序对应的指令，全局的数据。应用程序可以逐渐扩展自己的内存，但是**应用程序并没有直接访问物理内存的权限**，例如**应用程序不能直接访问物理内存**的1000-2000这段地址。不能直接访问的原因是，操作系统会提供内存隔离并控制内存，操作系统会在应用程序和硬件资源之间提供一个中间层。exec是这样一种系统调用，它表明了应用程序不能直接访问物理内存。

5. files基本上来说抽象了磁盘。**应用程序不会直接读写挂在计算机上的磁盘本身**，并且在Unix中这也是不被允许的。在Unix中，与存储系统交互的唯一方式就是通过files。Files提供了非常方便的磁盘抽象，你可以对文件命名，读写文件等等。之后，**操作系统会决定如何将文件与磁盘中的块对应，确保一个磁盘块只出现在一个文件中，并且确保用户A不能操作用户B的文件**。通过files的抽象，可以**实现不同用户之间和同一个用户的不同进程之间的文件强隔离。**













