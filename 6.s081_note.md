## 第一章

1. 操作系统一般需要做到：
   + 抽象硬件，实现了高层级的接口和抽象，例如进程，文件系统。
   + 在多个应用程序之间共用硬件资源，多个程序能够互不干扰地运行，multiplex（多路复用）。
   + 多个程序之间互不干扰。隔离性（Isolation），不同的活动之间不能相互干扰。
   + 能在需要的时候实现共享（Sharing）。
   + Security或者Permission System或者是Access Control System（权限系统或者门禁系统）。
   + 不阻止应用程序获得高性能，甚至需要帮助应用程序获得高性能（Performance）。
   + 同一个操作系统需要能够支持大量不同的用户场景。
2. Kernel中的服务：文件系统，进程管理系统。
3. 系统调用与程序中的函数调用的区别是系统调用会实际运行到系统内核中，并执行内核中对于系统调用的实现。Kernel会有特殊的权限能直接访问各种各样的硬件，例如磁盘。而普通的用户程序是没有办法直接访问这些硬件的。
4. 构建操作系统时，在操作系统下面就是硬件，编程环境比较恶劣。1.高效易用—接近硬件底层，为应用程序提供抽象的高层的可移植接口。2.要提供一个简单的接口，同时又包含了强大的功能。3.需要内核具备灵活的接口，又需要在某种程度上限制应用程序，因为你会想要安全性。我们希望给程序员完全的自由，但是实际上又不能是真正的完全自由。
5. fork还会拷贝文件描述符表单。两个进程的指令是一样的，数据是一样的，栈是一样的，同时，两个进程又有各自独立的地址空间，它们都认为自己的内存从0开始增长，但这里是不同的内存。有一些细节偶尔会导致父子进程不一致。子进程fork()返回0,父进程返回子进程进程号。子进程不会从main()函数开始执行，而是直接从fork()系统调用返回，就好像是他自己调用了fork。
6. `exec("filename"，argv)`从指定的文件中读取并加载指令，并替代当前调用进程的指令。会保留当前的文件描述符表单，通常来说exec系统调用不会返回，除非调用出错返回-1。
7. Shell会执行fork，之后fork出的子进程再调用exec系统调用。
8. `fork()`的子进程用`exit(num)`退出后，在父进程中可以用`wait(&status)`来获取子进程的退出状态。wait()的返回值是子进程号，`status`的值即是子进程`exit()`的参数的值。
9. 如果没有子进程的进程调用了wait，wait会立即返回-1，表明出现错误了。没有直接的方法让子进程等待父进程退出。
10. 如果一个进程调用fork两次，如果它想要等两个子进程都退出，它需要调用wait两次。每个wait会在一个子进程退出时立即返回。当wait返回时，你实际上没有必要知道哪个子进程退出了，但是wait返回了子进程的进程号，所以在wait返回之后，你就可以知道是哪个子进程退出了。
11. `int fd[2]; pipe(fd)`创建管道，`fd[0]`用来从管道读数据，`fd[1]`用来向管道写数据。返回0代表成功，返回-1失败。管道是不是文件取决于操作系统创建管道的方式，一般来说用pipe()创建的管道都不是文件。而创建基于文件的管道，通常叫做有名管道或FIFO文件（先进先出文件）。两个进程只要知道管道的名字也能用它来通信，即使它们是非父子进程关系。如果试图读取一个空的管道，也不会发生错误，因为程序会等待管道中出现东西。当子进程结束时，管道会关闭。f`gets()`将会收到`EOF`(End Of File,文件结束符） ，于是`fgets()`函数返回0，循环就结束了。管道只能单向通信。但是可以通过创建两个管道，一个从父进程连接到子进程，另一个从子进程连接到父进程来实现双向通信 。

