用计算机的思维，首先将5位运动员讲的话以说对一半的形式翻译成5个判断语句，这里所谓的“说对一半”，就是5位运动员中一句话为真，一句话为假。翻译成判断语句如下：
`A = (((b == 2) && (a == 3)) == 0) && (((b == 2) || (a == 3)) == 1);`
`B = (((b == 2) && (e == 4)) == 0) && (((b == 2) || (e == 4)) == 1);`
`C = (((c == 1) && (d == 2)) == 0) && (((c == 1) || (d == 2)) == 1);`
`D = (((c == 5) && (d == 3)) == 0) && (((c == 5) || (d == 3)) == 1);`
`E = (((e == 4) && (a == 1)) == 0) && (((e == 4) || (a == 1)) == 1);`
满足`A+B+C+D+E==5`或`A*B*C*D*E=1`就能模拟5位运动员说的话了。 或者：
`A = (b == 2) + (a == 3);`
`B = (b == 2) + (e == 4);`
`C = (c == 1) + (d == 2);`
`D = (c == 5) + (d == 3);`
`E = (e == 4) + (a == 1);`
满足`A*B*C*D*E=1`就能模拟5位运动员说的话了。  
然后就是将所有的可能情况列出来，去通过这5个判断，如果满足`A*B*C*D*E=1`就能得到比赛的名次。  对于怎么得出所有的比赛名次情况，有两种方法：
**方法1**：使用5个嵌套的循环将所有`1`  `2`  `3`  `4`  `5`名次组合数得出来，但是名次是不能出现重复的，那我们就将得到的组合数全部乘起来，如果结果等于`1*2*3*4*5=120`，就满足得到的组合数每个都不相同，这样名次就不会重复了。 
**方法2**：使用随机数，得到5个范围为`1~5`的数，同理为了避免名次重复，通过判断5个数的乘积结果是否为`120`，来筛选没有重复数字的组合。 
**:key:编程代码与运行结果**  方法1编程代码：

```c
#include <stdio.h>int main(){ int a = 0; int b = 0;    int c = 0;    int d = 0;    int e = 0;    int A = 0;    int B = 0;    int C = 0;    int D = 0;    int E = 0;    int test = 0;    for (a = 1; a <= 5; a++)    {        for (b = 1; b <= 5; b++)        {            for (c = 1; c <= 5; c++)            {                for (d = 1; d <= 5; d++)                {                    for (e = 1; e <= 5; e++)                    {                        if (a * b * c * d * e == 120)//生成五位选手所有排名可能                        {                            A = (((b == 2) && (a == 3)) == 0) && (((b == 2) || (a == 3)) == 1);                            B = (((b == 2) && (e == 4)) == 0) && (((b == 2) || (e == 4)) == 1);                            C = (((c == 1) && (d == 2)) == 0) && (((c == 1) || (d == 2)) == 1);                            D = (((c == 5) && (d == 3)) == 0) && (((c == 5) || (d == 3)) == 1);                            E = (((e == 4) && (a == 1)) == 0) && (((e == 4) || (a == 1)) == 1);                            //A = (b == 2) + (a == 3);                            //B = (b == 2) + (e == 4);                            //C = (c == 1) + (d == 2);                            //D = (c == 5) + (d == 3);                            //E = (e == 4) + (a == 1);                            //test = A + B + C + D + E;//满足五位选手说的话半句真半句假，后面判断条件要要改为test == 5;                            test = A * B * C * D * E;//满足五位选手说的话为半真                            if (a * b * c * d * e == 120)                            {                                if (test == 1)                                {                                    printf("A->%d B->%d C->%d D->%d E->%d\n", a, b, c, d, e);                                    break;                                }                            }                        }                    }                }            }        }    }    return 0;}
```

方法1运行结果：A->3 B->1 C->5 D->2 E->4D
方法2编程代码：

```c
#include <stdio.h>#include <time.h>#include <stdlib.h>int main(){    int a = 0;    int b = 0;    int c = 0;    int d = 0;    int e = 0;    int A = 0;    int B = 0;    int C = 0;    int D = 0;    int E = 0;    int test = 0;    srand((unsigned int)time(NULL));    while(1)    {        a = rand() % 5 + 1;        b = rand() % 5 + 1;        c = rand() % 5 + 1;        d = rand() % 5 + 1;        e = rand() % 5 + 1;//利用随机数生成五位选手排名可能情况                if (a * b * c * d * e == 120)        {            //A = (((b == 2) && (a == 3)) == 0) && (((b == 2) || (a == 3)) == 1);            //B = (((b == 2) && (e == 4)) == 0) && (((b == 2) || (e == 4)) == 1);            //C = (((c == 1) && (d == 2)) == 0) && (((c == 1) || (d == 2)) == 1);            //D = (((c == 5) && (d == 3)) == 0) && (((c == 5) || (d == 3)) == 1);            //E = (((e == 4) && (a == 1)) == 0) && (((e == 4) || (a == 1)) == 1);            A = (b == 2) + (a == 3);            B = (b == 2) + (e == 4);            C = (c == 1) + (d == 2);            D = (c == 5) + (d == 3);            E = (e == 4) + (a == 1);            test = A * B * C * D * E;//满足五位选手说的话为半真            if (test == 1)            {                printf("A->%d B->%d C->%d D->%d E->%d\n", a, b, c, d, e);//如果得出排名打印并退出循环                break;            }        }    }    return 0;}
```

方法2运行结果：A->3 B->1 C->5 D->2 E->4D。
两种方法结果一致，都得到了五位比赛选手的排名。

### 第二题：

![数组指针的存储图](https://img-blog.csdnimg.cn/20210429150750770.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Jlc2V0bQ==,size_16,color_FFFFFF,t_70)

    第一个printf，cpp先自加变成1，即cpp的中存放的地址由cp变成了cp+1，再解引用两次，此时得到了字符串LINUX
    第二个printf，cpp先自加变成2，即cpp的中存放的地址由cp+1变成了cp+2，再解引用得到指向c+1的指针，此时给c+1自减得到c的地址，再解引用，此时得到了字符串XI的地址，是char*类型的，此时做指针的+3运算，指向XI的下一个字符串YOU的Y，即输出YOU。
    第三个printf，首先确认cpp此时的值为2，先[-2]得到了指向c+3的地址，再解引用此时指针指向字符串GROUP，此时做指针的+3运算，指向GROUP中的U输出剩余字符串，即输出UP。
    第四个printf，首先确认cpp在第三次没有对自身做运算，此时它的值还是2。此时做第一个[-1]，得到cp+1再解引用，得到的是指向指向c+2的指针，再做一次[-1]，得到c+1再解引用，得到指向字符串YOU的指针，此时做指针的+1运算，指向YOU中的O再输出剩余字符串，即输出OU。

LINUX
YOU
UP
OU

### 第三题：

p指向的是结构体s的首地址
并且的 s.p 指针其实就是 p[1]
所以，当执行到 s.p[1] = 1;之后 s.p指向地址0x00000001的地方 所以当执行 s.p[2] = 2的时候其实是想0x00000001的地方写数字 2
你说死不死？

### 第四题：

0 1 0 12 8 8

p是数组，存在于栈上，这个写法是用hellow,world初始化数组元素，等价一个拷贝;

p1是一个指针，指向字符串常量hello，world，而这个字符串常量存在于全局常量区;

p2是一个指针，指向字符串常量hello, world,而这个字符串已经存在于全局常量区了，所以p2保存的地址与p1相同;

编译器是这样实现的相同的字符串常量在全局数据区只有一份拷贝
