## 马踏棋盘

                  **小组成员：袁野，李富，秦伟明，魏博斌，段雨超，罗嘉琪。**

**袁野：终端打印界面优化和文档编写。**

**秦伟明：程序设计和代码编写。**

**其他人负责舞伴问题和表达式求值问题。**

#### 一. 问题简述

        在一个国际象棋棋盘上，国际象棋的马从某一个位置开始，按照走“日”字对角线的走法，踏遍所有的位置。        

<img title="" src="file:///home/yuanye/Picture/截图/截图%202022-10-12%2013-59-47.png" alt="截图 2022-10-12 13-59-47.png" width="424" data-align="center">

#### 二. 思路

1. 用一个二维数组表示棋盘上的所有位置和长宽，最后决定马的走法后，每个位置数表示马第几步走到了这里。

2. 马的踏的每一步，最多有八个落点，八个落点中存在有的位置已经走过或者越界，无法走，最终有如下情况：
   
   + 如果有可落点，选取一个走，然后继续选择。
   
   + 如果没有可落点，马回到上一步所在位置（回溯），选择除当前位置之外的落点，然后继续选择。

3. 最终走了X*Y步，说明有解，输出结果，如果最终第一步的八个位置的所有可能走法都尝试过了，说明无解。
   
   ![截图 2022-10-12 13-40-36.png](/home/yuanye/Picture/截图/截图%202022-10-12%2013-40-36.png)

#### 三.程序设计

1. chess[X][Y]表示棋盘上每个位置和长宽，保存步数。

2. begin_x和bgein_y表示起始位置横纵坐标，x,y表示当前坐标。

3. count表示八个落点中的一个(0~7)。

4. 函数setHorse()来进行每一步的选择，返回1表示成功找到落脚点，返回0表示没有找到落脚点，它需要三个参数：当前所在位置x,y和当前步数tag。

5. 函数next()来判断马能否跳到某一个落点，返回1表示可以，返回0表示不可以，它需要三个参数：当前所在位置x,y和要判断的落点count。

### 四.代码分析

```c
#define X 6 // 棋盘宽度
#define Y 6 // 棋盘长度
#define YELLOW "\e[1;33m" // 黄
#define U_YELLOW "\e[4;1;33m" // 下划线加黄色
#define GREEN "\e[4;1;36m" // 下划线加绿色
#define UNDER "\e[4m" // 下划
#define NONE "\e[0m"
```

```c
int chess[X][Y];
int next(int *px, int *py, int count);
int setHorse(int x, int y, int tag);
```

### 五.关于递归

+ 递归，就是函数在运行的过程中调用自己。

+ 必须要有终止递归的条件。

+ 递归调用之前的代码，由外层向内层依次执行。

+ 递归调用之后的代码，由内层向外层依次执行。

### 六.关于深度优先搜索(DFS)

+ 深度优先搜索（DFS）是搜索算法的一种，它从某一个状态开始，不断地转移状态直到无法转移，然后回退到前一步的状态，继续转移到其他状态，如此不断重复，直到找到最终的解。

+ 一个问题可以分割成如干个相似的小问题的连续解决，且前一个问题的解决决定了下一个问题的起始状态。
  
  ![截图 2022-10-12 13-40-36.png](/home/yuanye/Picture/截图/截图%202022-10-12%2013-40-36.png)

### 七.关于优化(贪心)

主要的贪心思路就是：
找到马当前所在位置的下一个落脚点（次落点）的集合p。再计算p里面每一个落脚点的下一个落脚点（次次落点）的个数，按照此次节点的个数，将集合p里面的次落点按照非递减顺序排列，从次次落点数量最少的次落点开始尝试。
